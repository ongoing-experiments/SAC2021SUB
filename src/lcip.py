import numpy as np
from shapely.geometry import Point, Polygon, LineString, MultiPolygon
from shapely.geometry import GeometryCollection, mapping

import shapely.wkt
from shapely.wkt import dumps, loads
import math
from MSeg import MSeg
import sys

"""

    Examples:

    python line-rip.py 'LineString (-0.75283631820074914 0.70959600166597325, 2.35466888796335061 0.64708871303623572)' 'LineString (-0.73497709287796686 1.13821740941274596, 0.28299875052061729 1.63827571845064712, 0.5062390670553949 1.29002082465639445, 0.24728029987505318 1.25430237401082989, 0.24728029987505318 1.42396501457726066, -0.0027488546438974 1.29002082465639445, 0.29192836318200843 1.04892128279883501, 0.72054977092878092 1.07571012078300843, 0.63125364431486997 1.45075385256143408, 0.20263223656809748 1.83472719700125109, 0.90807163681799397 1.71864223240316694, 0.88128279883382055 1.34359850062474084, 1.25632653061224664 1.1024989587671814, 2.05999167013744477 1.3793169512703054)' '6' '100' '0'

    python line-rip.py 'LineString (-0.75283631820074914 0.70959600166597325, 2.35466888796335061 0.64708871303623572)' 'LineString (-0.73497709287796686 1.13821740941274596, -0.27865566218157345 1.43112920636809582, -0.34710387678603249 1.49672541203070253, -0.28435968006527834 1.57658166240257147, -0.19309539392599961 1.69351402901852222, -0.2045034296934094 1.4596492957866205, 0.0350653214221972 1.47390934049588296, 0.23451459850912548 1.63257170056694223, 0.5062390670553949 1.29002082465639445, 0.24728029987505318 1.25430237401082989, 0.24728029987505318 1.42396501457726066, -0.0027488546438974 1.29002082465639445, 0.29192836318200843 1.04892128279883501, 0.72054977092878092 1.07571012078300843, 0.63125364431486997 1.45075385256143408, 0.20263223656809748 1.83472719700125109, 0.90807163681799397 1.71864223240316694, 0.88128279883382055 1.34359850062474084, 1.25632653061224664 1.1024989587671814, 2.05999167013744477 1.3793169512703054)' '6' '100' '0'

    python line-rip.py 'LineString (-0.75283631820074914 0.70959600166597325, 2.35466888796335061 0.64708871303623572)' 'LineString (-0.73497709287796686 1.13821740941274596, -0.27865566218157345 1.43112920636809582, -0.34710387678603249 1.49672541203070253, -0.37384146061589896 1.44467624884189605, -0.42802963051109572 1.46178830249301073, -0.43088163945294816 1.51312446344635498, -0.40236155003442353 1.55020057969043701, -0.36243342484848912 1.59298071381822393, -0.29113320130217757 1.5851376892281297, -0.24906606940985382 1.65073389489073641, -0.19309539392599961 1.69351402901852222, -0.18133085704085783 1.58870270040544526, -0.23694503140698076 1.53166252156839611, -0.2045034296934094 1.4596492957866205, 0.0350653214221972 1.47390934049588296, 0.10387003714438825 1.5559045975741419, 0.06251590748752767 1.64574287924249441, 0.15948421151051129 1.60724075852748616, 0.23451459850912548 1.63257170056694223, 0.5062390670553949 1.29002082465639445, 0.24728029987505318 1.25430237401082989, 0.24728029987505318 1.42396501457726066, -0.0027488546438974 1.29002082465639445, 0.2022643456382982 1.18656943960424877, 0.29352863177757693 1.17516140383683876, 0.33060474802165896 1.20368149325536344, 0.37053287320759343 1.19227345748795366, 0.39334894474241322 1.15234533230201919, 0.31919671225424917 1.10386118029052738, 0.29192836318200843 1.04892128279883501, 0.72054977092878092 1.07571012078300843, 0.63125364431486997 1.45075385256143408, 0.20263223656809748 1.83472719700125109, 0.90807163681799397 1.71864223240316694, 0.88128279883382055 1.34359850062474084, 1.25632653061224664 1.1024989587671814, 2.05999167013744477 1.3793169512703054)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.10204081632653006 0.31326530612244885, -1.0326530612244893 0.333673469387755, -1.00408163265306127 0.28163265306122448, -0.94897959183673419 0.33775510204081616, -0.91224489795918318 0.26632653061224476, -0.94285714285714239 0.17040816326530595, -0.99387755102040765 0.06020408163265295, -0.94693877551020367 0.07040816326530597, -0.92244897959183625 0.11326530612244884, -0.85306122448979549 0.10510204081632635, -0.8775510204081628 0.03163265306122431, -1.00612244897959124 -0.0642857142857145, -1.11632653061224474 -0.13877551020408174, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.23877551020408183 -0.08571428571428585, 0.99795918367347003 0.32346938775510198, 0.94897959183673519 0.24387755102040809, 0.81224489795918431 0.30714285714285711)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.09591836734693882 0.36734693877551017, -0.98979591836734704 0.25714285714285712, -1.11632653061224474 -0.13877551020408174, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.06734693877551035 -0.00816326530612255, 0.78163265306122476 0.42448979591836733)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.03871604518525262 0.2484907118426537, -1.0326530612244893 0.333673469387755, -1.00408163265306127 0.28163265306122448, -0.94897959183673419 0.33775510204081616, -0.91224489795918318 0.26632653061224476, -0.94285714285714239 0.17040816326530595, -0.99387755102040765 0.06020408163265295, -0.94693877551020367 0.07040816326530597, -0.92244897959183625 0.11326530612244884, -0.85306122448979549 0.10510204081632635, -0.8775510204081628 0.03163265306122431, -1.00612244897959124 -0.0642857142857145, -1.11632653061224474 -0.13877551020408174, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.23877551020408183 -0.08571428571428585, 0.99795918367347003 0.32346938775510198, 0.94897959183673519 0.24387755102040809, 0.81224489795918431 0.30714285714285711)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.03871604518525262 0.2484907118426537, -1.0326530612244893 0.333673469387755, -1.00408163265306127 0.28163265306122448, -0.94897959183673419 0.33775510204081616, -0.91224489795918318 0.26632653061224476, -0.94285714285714239 0.17040816326530595, -1.15057163681799235 0.14209704289879188, -0.94693877551020367 0.07040816326530597, -0.92244897959183625 0.11326530612244884, -0.85306122448979549 0.10510204081632635, -0.8775510204081628 0.03163265306122431, -1.00612244897959124 -0.0642857142857145, -1.18181278633902531 -0.13907330279050434, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.23877551020408183 -0.08571428571428585, 0.99795918367347003 0.32346938775510198, 0.94897959183673519 0.24387755102040809, 0.81224489795918431 0.30714285714285711)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.03871604518525262 0.2484907118426537, -1.0326530612244893 0.333673469387755, -1.00408163265306127 0.28163265306122448, -0.94897959183673419 0.33775510204081616, -0.91224489795918318 0.26632653061224476, -0.94285714285714239 0.17040816326530595, -0.99387755102040765 0.06020408163265295, -0.94693877551020367 0.07040816326530597, -0.92244897959183625 0.11326530612244884, -0.85306122448979549 0.10510204081632635, -0.8775510204081628 0.03163265306122431, -1.00612244897959124 -0.0642857142857145, -1.11632653061224474 -0.13877551020408174, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.23877551020408183 -0.08571428571428585, 0.99795918367347003 0.32346938775510198, 0.94897959183673519 0.24387755102040809, 0.81224489795918431 0.30714285714285711)' '6' '100' '0'

    python line-rip.py 'LineString (-1.1693877551020404 -0.75918367346938775, 1.19795918367346999 -0.42448979591836733)' 'LineString (-1.03871604518525262 0.2484907118426537, -1.0326530612244893 0.333673469387755, -1.00408163265306127 0.28163265306122448, -0.94897959183673419 0.33775510204081616, -0.91224489795918318 0.26632653061224476, -0.94285714285714239 0.17040816326530595, -0.99387755102040765 0.06020408163265295, -0.94693877551020367 0.07040816326530597, -0.92244897959183625 0.11326530612244884, -0.85306122448979549 0.10510204081632635, -0.8775510204081628 0.03163265306122431, -1.00612244897959124 -0.0642857142857145, -1.11632653061224474 -0.13877551020408174, -0.88775510204081631 -0.18775510204081636, -0.67959183673469381 -0.01224489795918382, -0.65918367346938767 0.16326530612244894, -0.58571428571428563 -0.01632653061224509, -0.5 0.2204081632653061, -0.39795918367346927 0.19999999999999996, -0.48367346938775513 -0.14285714285714302, -0.33265306122448979 0.02857142857142847, -0.34897959183673466 0.2857142857142857, -0.16530612244897958 0.27755102040816315, -0.30816326530612237 -0.07755102040816331, -0.21428571428571419 -0.29387755102040836, 0.01020408163265296 -0.2081632653061225, 0.04693877551020398 0.00816326530612232, -0.14489795918367343 0.01632653061224476, -0.04693877551020398 0.14285714285714279, 0.11224489795918391 0.08571428571428563, 0.30000000000000027 -0.08163265306122458, 0.11224489795918391 -0.17959183673469403, 0.25918367346938798 -0.29387755102040836, 1.23877551020408183 -0.08571428571428585, 0.99795918367347003 0.32346938775510198, 0.97202415660141694 0.28298261141191161, 0.92095689296126693 0.28148063306955423, 0.88971574344023407 0.21178883798417317, 0.84345481049562765 0.22981257809246136, 0.81461682632236654 0.18475322782174083)' '6' '100' '0'

"""

OPT = 0

def get_input():
        
    p_wkt = str(sys.argv[1])
    q_wkt = str(sys.argv[2])
    option = int(str(sys.argv[3]))
    n_obs = int(str(sys.argv[4]))
    debug = int(str(sys.argv[5]))

    p = loads(p_wkt)
    q = loads(q_wkt)
    
    return p, q, option, n_obs, debug

"""
https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/
"""
def orientation(p, q, r): 
    ''' 
    To find orientation of ordered triplet (p, q, r).  
    The function returns the following values:
        0 --> p, q and r are colinear  
        1 --> Clockwise  
        2 --> Counterclockwise  
    '''
    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y) 
    
    #A, B, C
    #return (B.x - A.x) * (C.y - A.y) > (B.y - A.y) * (C.x - A.x)
  
    if val == 0: 
        return 0
    elif val > 0: 
        return 1
    else: 
        return 2

"""
    O(n2)
"""
def convex_hull_2(points, n): 
      
    # There must be at least 3 points  
    if n < 3: 
        return
  
    # Find the leftmost point 
    #l = 12
    
    # O(n), n the number of points.
    l = Left_index(points) 
    
    #print(l)
    
    hull = [] 
      
    ''' 
    Start from leftmost point, keep moving counterclockwise  
    until reach the start point again. This loop runs O(h)  
    times where h is number of points in result or output.  
    '''
    p = l 
    q = 0
    
    while(True): 
          
        # Add current point to result  
        hull.append(p) 
  
        ''' 
        Search for a point 'q' such that orientation(p, x,  
        q) is counterclockwise for all points 'x'. The idea  
        is to keep track of last visited most counterclock-  
        wise point in q. If any point 'i' is more counterclock-  
        wise than q, then update q.  
        '''
        q = (p + 1) % n 
  
        for i in range(n): 
              
            # If i is more counterclockwise than current q, then update q  
            if(orientation(points[p], points[i], points[q]) == 2): 
                q = i 
  
        ''' 
        Now q is the most counterclockwise with respect to p  
        Set p as q for next iteration, so that q is added to  
        result 'hull'  
        '''
        p = q 
  
        # While we don't come to first point 
        if(p == l): 
            break
    
    return hull

"""
https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/

This code is contributed by Akarsh Somani, IIIT Kalyani 
"""
"""
def convex_hull(points, n): 
    # There must be at least 3 points  
    if n < 3: 
        return
  
    # Find the leftmost point 
    l = Left_index(points) 
    
    #l = 12
    
    hull = []
    #ids = [] 
      
    p = l 
    q = 0
    
    while(True): 
          
        # Add current point to result  
        hull.append(p) 
  
        q = (p + 1) % n 
  
        for i in range(n): 
              
            # If i is more counterclockwise than current q, update q.
            if orientation(points[p], points[i], points[q]) == 2: 
                q = i 
  
        p = q 
  
        # While we don't come to first point
        # original
        #if p == l:
        if p == l: 
            break
        
        if p == n - 1:
            hull.append(p)
            break
        
    return hull
"""

def Left_index(points): 
    ''' 
    Finding the left most point 
    '''
    
    minn = 0
    
    for i in range(1, len(points)): 
        if points[i].x < points[minn].x: 
            minn = i 
        elif points[i].x == points[minn].x: 
            if points[i].y > points[minn].y: 
                minn = i
    
    return minn 

def right_index(points): 
    ''' 
    Finding the right most point 
    '''
    
    maxn = 0
    
    for i in range(1, len(points)): 
        if points[i].x > points[maxn].x: 
            maxn = i 
        elif points[i].x == points[maxn].x: 
            if points[i].y < points[maxn].y: 
                maxn = i
    
    return maxn 

def right_index2(coords): 
    ''' 
    Finding the right most point 
    '''
    
    maxn = 0
    
    for i in range(1, len(coords)): 
        if coords[i][0] > coords[maxn][0]: 
            maxn = i 
        elif coords[i][0] == coords[maxn][0]: 
            if coords[i][1] < coords[maxn][1]: 
                maxn = i
    
    return maxn 

def get_transform(seg_coords, line_coords, i, j, poly = None):
    
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(seg_coords[1][0], seg_coords[1][1])  
        
    ii = i
    jj = j
    
    rviz = []
    lviz = []
        
    isegs = []
    _isegs = []
    _seg = []
    
    d = jj - ii
    
    if poly == None:
        _v = i
        _c = []
            
        while _v <= j:
            _c += [[line_coords[_v][0], line_coords[_v][1]]]
            _v += 1
            
        _c += [[line_coords[i][0], line_coords[i][1]]]
        
        poly = Polygon(_c)
    
    """
    if d == 2:
        isegs += [[i, i+1]]
        isegs += [[i+1, j]]
        
        #sys.exit()
        
    elif d == 3:       
        isegs += [[i, i+1]]
        isegs += [[i+1, i+2]]
        isegs += [[i+2, j]]
        
        #sys.exit()
    """
    if not poly.is_valid:
        #print(poly.wkt + ';')
        print_error('Unexpected error: get_transform(): not poly.is_valid !"')
        sys.exit()
        """
        _it = i
        while _it < j:
            isegs += [[_it, _it+1]]
            
            _it += 1
        """
    else:
        _line = LineString(line_coords)
        
        rviz += [ii + 1]
        pid = ii + 2
        
        con_to_last = False
        
        A = Point(line_coords[i][0], line_coords[i][1])
        B = Point(line_coords[i+1][0], line_coords[i+1][1])

        while True:
            C = Point(line_coords[pid][0], line_coords[pid][1])
            
            if orientation(A, B, C) == 1:
                _lseg_1 = LineString([[A.x, A.y], [C.x, C.y]])
                
                if not poly.relate_pattern(_lseg_1, '******T**'):
                    if pid == jj:
                        con_to_last = True
                    else:
                        rviz += [pid]
                    
            if pid == jj:
                break
                    
            pid += 1
        
        lviz = []
        
        A = Point(line_coords[j][0], line_coords[j][1])
        
        for el in rviz:
            C = Point(line_coords[el][0], line_coords[el][1])
            _lseg_1 = LineString([[A.x, A.y], [C.x, C.y]])
            
            if not poly.relate_pattern(_lseg_1, '******T**'):
                lviz += [el]
        """
        t = 0
        g = 0
        n = len(rviz)
        m = len(lviz)
        _viz = []
                
        while t < n and g < m:
            if rviz[t] == lviz[g]:
                _viz += [rviz[t]]
                t += 1
                g += 1
            elif rviz[t] < lviz[g]:
                t += 1
            else:
                g += 1
                
        viz = _viz
        """
        viz = lviz
        
        _viz = []
        
        if len(viz) > 2:
            _i = 0
            _f = len(viz)
            #_viz = [viz[_i], viz[_f-1]]    # got self-i in some cases.
            _viz += [viz[0], viz[1]]
            #_viz = [viz[0], viz[1], viz[2]]
            #viz = _viz
        
            #sys.exit()
        
            #viz = [viz[0]]
        
            """
            found = False
            _i = 0
            _f = len(viz)
            
            while _i < _f - 2:
                A = Point(line_coords[viz[_i]][0], line_coords[viz[_i]][1])
                B = Point(line_coords[viz[_i+1]][0], line_coords[viz[_i+1]][1])
                
                _lseg_1 = LineString([[A.x, A.y], [B.x, B.y]])
                if poly.relate_pattern(_lseg_1, '******T**'):
                    _i += 1
                    continue
                
                A = Point(line_coords[viz[_i+1]][0], line_coords[viz[_i+1]][1])
                B = Point(line_coords[viz[_i+2]][0], line_coords[viz[_i+2]][1])
                
                _lseg_1 = LineString([[A.x, A.y], [B.x, B.y]])
                if poly.relate_pattern(_lseg_1, '******T**'):
                    _i += 1
                    continue
                
                _viz += [viz[_i], viz[_i+1], viz[_i+2]]
                viz = _viz
                found = True
                break

            if not found:
                _i = 0
                while _i < _f - 1:
                    A = Point(line_coords[viz[_i]][0], line_coords[viz[_i]][1])
                    B = Point(line_coords[viz[_f-1]][0], line_coords[viz[_f-1]][1])
                    
                    _lseg_1 = LineString([[A.x, A.y], [B.x, B.y]])
                    if poly.relate_pattern(_lseg_1, '******T**'):
                        _i += 1
                        continue
                                        
                    _viz += [viz[_i], viz[_f-1]]
                    viz = _viz
                    found = True
                    break
            """
            
            """
            found = False
            
            if not found:
                viz = [viz[0]]
            """
        
        #viz = [viz[0]]
        
        _i = i
        for e in viz:
            isegs += [[_i, e]]

            if e - _i > 1:
                _seg_coords = [(line_coords[_i][0], line_coords[_i][1]), (line_coords[e][0], line_coords[e][1])]
                _isegs += get_transform(_seg_coords, line_coords, _i, e, poly)

            _i = e
                
        isegs += [[_i, j]]
        if j - _i > 1:
            _seg_coords = [(line_coords[_i][0], line_coords[_i][1]), (line_coords[j][0], line_coords[j][1])]
            _isegs += get_transform(_seg_coords, line_coords, _i, j, poly)
       
    isegs = [isegs]

    if len(_isegs) > 0:
        for _list in _isegs:
            isegs.append(_list)
    
    return isegs

"""
def get_transform2(seg_coords, line_coords, i, j, poly = None):

    path_max_len = 1

    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(seg_coords[1][0], seg_coords[1][1])  

    ii = i
    jj = j
    
    rviz = []
    lviz = []
        
    isegs = []
    _isegs = []
    _seg = []
    d = jj - ii
    
    if poly == None:
        _v = i
        _c = []
            
        while _v <= j:
            _c += [[line_coords[_v][0], line_coords[_v][1]]]
            _v += 1
            
        _c += [[line_coords[i][0], line_coords[i][1]]]
            
        poly = Polygon(_c)
    
    if d == 2:
        isegs += [[i, i+1]]
        isegs += [[i+1, j]]
    elif d == 3:
        isegs += [[i, i+1]]
        isegs += [[i+1, i+2]]
        isegs += [[i+2, j]]
    else:
        _line = LineString(line_coords)
               
        rviz += [ii + 1]
        pid = ii + 2
        
        con_to_last = False
        
        A = Point(line_coords[i][0], line_coords[i][1])
        B = Point(line_coords[i+1][0], line_coords[i+1][1])

        while True:
            C = Point(line_coords[pid][0], line_coords[pid][1])

            if orientation(A, B, C) == 1:
                _lseg_1 = LineString([[A.x, A.y], [C.x, C.y]])

                if not poly.relate_pattern(_lseg_1, '******T**'):
                    if pid == jj:
                        con_to_last = True
                    else:
                        rviz += [pid]

            if pid == jj:
                break
                    
            pid += 1
        
        lviz = []
        
        A = Point(line_coords[j][0], line_coords[j][1])
        
        for el in rviz:
            C = Point(line_coords[el][0], line_coords[el][1])
            _lseg_1 = LineString([[A.x, A.y], [C.x, C.y]])
            
            if not poly.relate_pattern(_lseg_1, '******T**'):
                lviz += [el]
        
        t = 0
        g = 0
        n = len(rviz)
        m = len(lviz)
        _viz = []
                
        while t < n and g < m:
            if rviz[t] == lviz[g]:
                _viz += [rviz[t]]
                t += 1
                g += 1
            elif rviz[t] < lviz[g]:
                t += 1
            else:
                g += 1
                
        viz = _viz
        
        _viz = []
        
        if len(viz) > 2:
            found = False
            _i = 0
            _f = len(viz)
                        
            found = False
            
            if not found:
                viz = [viz[0]]

        _i = i
        for e in viz:
            isegs += [[_i, e]]

            if e - _i > 1:
                _seg_coords = [(line_coords[_i][0], line_coords[_i][1]), (line_coords[e][0], line_coords[e][1])]
                _isegs += get_transform2(_seg_coords, line_coords, _i, e, poly)

            _i = e
                
        isegs += [[_i, j]]
        if j - _i > 1:
            _seg_coords = [(line_coords[_i][0], line_coords[_i][1]), (line_coords[j][0], line_coords[j][1])]
            _isegs += get_transform2(_seg_coords, line_coords, _i, j, poly)
    
    isegs = [isegs]
    if len(_isegs) > 0:
        for _list in _isegs:
            isegs.append(_list)
    
    return isegs, path_max_len
"""

"""
def get_msegs(seg_coords, line_coords, hull, i, j, s_t, e_t, seg_2_seg):
    isegs = []
    
    if seg_2_seg:
        isegs = [[i, j]]
    else:
        isegs = get_transform(seg_coords, line_coords, i, j)
        
    return isegs
"""

def get_isegs(seg_coords, line_coords, hull, i, j, seg_2_seg):
    isegs = []
    
    if seg_2_seg:
        isegs = [[i, j]]
    else:
        isegs = get_transform(seg_coords, line_coords, i, j)

    return isegs

def get_msegs_from_isegs(line_coords, isegs, s_t, n, dt, idx):
    msegs = []
        
    iseg = isegs[idx]
    
    g_idx = idx
        
    m = len(iseg)
    
    i = iseg[0][0]
    j = iseg[m - 1][1]
        
    A = Point(line_coords[i][0], line_coords[i][1])
    B = Point(line_coords[j][0], line_coords[j][1])
        
    f = float(1) / (m)
    
    segs = []
    
    dx = (B.x - A.x)
    dy = (B.y - A.y)
    
    xstep = dx * f
    ystep = dy * f
    
    h = 0   
    tup = (A.x, A.y)
        
    while h < m:
        if h == m - 1:
            segs += [[tup, (B.x, B.y)]]
        else:
            x = A.x + xstep * (h+1)
            y = A.y + ystep * (h+1)
            
            segs += [[tup, (x, y)]]
            tup = (x, y)
        
        h += 1

    if g_idx == n:
        sys.exit()
        g = 0
        e_t = s_t + dt
 
        if m == 2:      
            sseg = segs[g]
            tseg = [(line_coords[iseg[g][0]][0], line_coords[iseg[g][0]][1]), (line_coords[iseg[g][1]][0], line_coords[iseg[g][1]][1])]
                    
            B = Point(sseg[1][0], sseg[1][1])
            D = Point(tseg[1][0], tseg[1][1])
            
            msegs += [MSeg(B, B, D, D, s_t, e_t, True)]
        else:
            while g < m:
                sseg = segs[g]
                tseg = [(line_coords[iseg[g][0]][0], line_coords[iseg[g][0]][1]), (line_coords[iseg[g][1]][0], line_coords[iseg[g][1]][1])]
                
                A = Point(sseg[0][0], sseg[0][1])
                B = Point(sseg[1][0], sseg[1][1])
                
                C = Point(tseg[0][0], tseg[0][1])
                D = Point(tseg[1][0], tseg[1][1])
                
                if g == 0:
                    msegs += [MSeg(B, B, C, D, s_t, e_t, True)]
                elif g == m - 1:
                    msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                else:
                    msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                    msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
                    
                g += 1
    else:
        g = 0
        e_t = s_t + dt
        
        if e_t > 1:
            e_t = 1
        
        if m == 2:
            sseg = segs[g]
            tseg = [(line_coords[iseg[g][0]][0], line_coords[iseg[g][0]][1]), (line_coords[iseg[g][1]][0], line_coords[iseg[g][1]][1])]
                        
            A = Point(sseg[0][0], sseg[0][1])
            B = Point(sseg[1][0], sseg[1][1])
            
            C = Point(tseg[0][0], tseg[0][1])
            D = Point(tseg[1][0], tseg[1][1])
                        
            msegs += [MSeg(B, B, D, D, s_t, e_t)]
            
            _D = Point((line_coords[iseg[1][1]][0], line_coords[iseg[1][1]][1]))
                        
            if iseg[0][0] + 1 == iseg[0][1]:
                msegs += [MSeg(D, D, D, D, e_t, 1)]
                
                if iseg[1][0] + 1 != iseg[1][1]:
                    g_idx += 1
                    
                    _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                    msegs += _msegs

                msegs += [MSeg(_D, _D, _D, _D, e_t, 1)]
            else:
                msegs += [MSeg(A, A, A, A, e_t, 1)]
                
                g_idx += 1
                
                _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                msegs += _msegs
                
                msegs += [MSeg(D, D, D, D, e_t, 1)]
                                
                if iseg[1][0] + 1 != iseg[1][1]:
                    g_idx += 1
                    
                    _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                    msegs += _msegs

                msegs += [MSeg(_D, _D, _D, _D, e_t, 1)]
        else:
            while g < m:
                sseg = segs[g]
                tseg = [(line_coords[iseg[g][0]][0], line_coords[iseg[g][0]][1]), (line_coords[iseg[g][1]][0], line_coords[iseg[g][1]][1])]
                
                A = Point(sseg[0][0], sseg[0][1])
                B = Point(sseg[1][0], sseg[1][1])
                
                C = Point(tseg[0][0], tseg[0][1])
                D = Point(tseg[1][0], tseg[1][1])
                
                if g == 0:
                    msegs += [MSeg(B, B, C, D, s_t, e_t)]
                    
                    if iseg[g][0] + 1 != iseg[g][1]:
                        msegs += [MSeg(A, A, A, A, e_t, 1)]
                        
                        g_idx += 1
                        _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                        msegs += _msegs
                    
                    msegs += [MSeg(D, D, D, D, e_t, 1)]
                elif g == m - 1:
                    msegs += [MSeg(A, A, C, D, s_t, e_t)]
                    msegs += [MSeg(C, C, C, C, e_t, 1)]
                    
                    if iseg[g][0] + 1 != iseg[g][1]:
                        g_idx += 1
                        _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                        msegs += _msegs

                    msegs += [MSeg(D, D, D, D, e_t, 1)]
                else:                
                    msegs += [MSeg(A, A, C, D, s_t, e_t)]
                    msegs += [MSeg(A, B, D, D, s_t, e_t)]
                    
                    msegs += [MSeg(C, C, C, C, e_t, 1)]
                    
                    if iseg[g][0] + 1 != iseg[g][1]:
                        g_idx += 1
                        _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, n, dt, g_idx)
                        msegs += _msegs

                    msegs += [MSeg(D, D, D, D, e_t, 1)]
                
                g += 1
            
    return msegs, g_idx

def get_max_path_len(iseg, transform, idx):
    path_len = []
    _next_t = None
    
    next_t = iseg[idx]
    
    for _t in next_t:
        if _t[0] + 1 == _t[1]:
            path_len += [1]
        else:
            _idx = idx
            _next_t = None

            while True:
                _next_t = iseg[_idx]
                n = len(_next_t)
                
                if _next_t[0][0] == _t[0] and _next_t[n - 1][1] == _t[1]:
                    break

                _idx += 1
        
            _max_len = get_max_path_len(iseg, _next_t, _idx)
            path_len += [_max_len + 1]
    
    return max(path_len)

#O(knm)
# number of isegs
# number of initial trabsformayions on the isegs
# number of transformations after the initial transformation.
# tr_final_t > transformation final t
def get_time_step_from_isegs(isegs, e_t, tr_final_t = 1):
    time_step = []
    
    h = 0
    
    for iseg in isegs:
    
        #print(iseg)
    
        t = iseg[0]
        path_max_len = 1

        for _t in t:
            #print(_t)
            
            if _t[0] + 1 != _t[1]:
            
                idx = 1
                _next_t = None

                while True:
                    _next_t = iseg[idx]
                    n = len(_next_t)
                    
                    if _next_t[0][0] == _t[0] and _next_t[n - 1][1] == _t[1]:
                        break

                    idx += 1
                
                path_len = get_max_path_len(iseg, _t, idx) + 1
                if path_max_len < path_len:
                    path_max_len = path_len
                
        #dt = float(1 - e_t) / (path_max_len)
        dt = 0
        if tr_final_t != 1 and h == 2:
            dt = float(tr_final_t - e_t) / (path_max_len)
        else:
            dt = float(1 - e_t) / (path_max_len)
        
        time_step += [[dt, path_max_len]]
        h += 1
    
    #sys.exit()
    
    return time_step

def print_error(message):
    print(0)
    print(0)
    print(0)
    print(message)

def seg_to_line_5(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg = loads('LineString (-1.25102040816326543 -0.73877551020408183, 0.93673469387755137 -0.59183673469387776)')
    
    l = loads('LineString (-1.3040816326530611 -0.17551020408163276, -0.83469387755102042 -0.26938775510204094, -0.77346938775510199 -0.06938775510204098, -0.86734693877551017 0.02448979591836731, -0.94489795918367347 -0.01224489795918382, -0.97346938775510194 0.04081632653061218, -0.86734693877551017 0.1020408163265305, -0.78163265306122454 0.02857142857142847, -0.72123661799388505 0.03752937718888849, -0.67959183673469381 0.10612244897959178, -0.74519746809134857 0.19218577327251635, -0.67549317689872757 0.24446399166698207, -0.6020408163265305 0.14285714285714279, -0.51632653061224487 0.20408163265306112, -0.41628034402616809 0.25971180536536792, -0.2790500207406954 0.25317702806605974, -0.18571428571428572 0.19999999999999996, -0.09591836734693882 0.06122448979591832, -0.06775888806306307 -0.0539575050014266, -0.05904585166398535 -0.12366179619404771, -0.07551020408163245 -0.21632653061224505, 0.14897959183673493 -0.33061224489795937, 0.83061224489795915 -0.05306122448979611)')
    #l = loads('LineString (-1.3040816326530611 -0.17551020408163276, -0.83469387755102042 -0.26938775510204094, -0.77346938775510199 -0.06938775510204098, -0.86734693877551017 0.02448979591836731, -0.94489795918367347 -0.01224489795918382, -0.97346938775510194 0.04081632653061218, -0.86734693877551017 0.1020408163265305, -0.78163265306122454 0.02857142857142847, -0.72123661799388505 0.03752937718888849, -0.67959183673469381 0.10612244897959178, -0.74519746809134857 0.19218577327251635, -0.67549317689872757 0.24446399166698207, -0.6020408163265305 0.14285714285714279, -0.51632653061224487 0.20408163265306112, -0.41628034402616809 0.25971180536536792, -0.2790500207406954 0.25317702806605974, -0.2311283205457686 0.3119900237598337, -0.16360228845291691 0.2771378781635232, -0.18571428571428572 0.19999999999999996, -0.09591836734693882 0.06122448979591832, -0.06775888806306307 -0.0539575050014266, -0.05904585166398535 -0.12366179619404771, -0.07551020408163245 -0.21632653061224505, 0.14897959183673493 -0.33061224489795937, 0.83061224489795915 -0.05306122448979611)')
    #l = loads('LineString (-1.3040816326530611 -0.17551020408163276, -0.83469387755102042 -0.26938775510204094, -0.77346938775510199 -0.06938775510204098, -0.86734693877551017 0.02448979591836731, -0.94489795918367347 -0.01224489795918382, -0.97346938775510194 0.04081632653061218, -0.86734693877551017 0.1020408163265305, -0.78163265306122454 0.02857142857142847, -0.71632653061224483 0.00816326530612232, -0.67959183673469381 0.10612244897959178, -0.76530612244897966 0.19999999999999996, -0.66326530612244894 0.2204081632653061, -0.6020408163265305 0.14285714285714279, -0.51632653061224487 0.20408163265306112, -0.41428571428571415 0.30204081632653057, -0.25102040816326521 0.26938775510204072, -0.17755102040816317 0.33061224489795915, -0.15714285714285703 0.28979591836734686, -0.18571428571428572 0.19999999999999996, -0.09591836734693882 0.06122448979591832, 0.00612244897959213 -0.05714285714285716, 0.16530612244897958 0.03265306122448974, 0.24285714285714288 0.01632653061224476, 0.02653061224489806 -0.1183673469387756, -0.07551020408163245 -0.21632653061224505, 0.14897959183673493 -0.33061224489795937, 0.83061224489795915 -0.05306122448979611)')
    #l = loads('LineString (-1.3040816326530611 -0.17551020408163276, -0.83469387755102042 -0.26938775510204094, -0.77346938775510199 -0.06938775510204098, -0.86734693877551017 0.02448979591836731, -0.94489795918367347 -0.01224489795918382, -0.97346938775510194 0.04081632653061218, -0.86734693877551017 0.1020408163265305, -0.78163265306122454 0.02857142857142847, -0.71632653061224483 0.00816326530612232, -0.67959183673469381 0.10612244897959178, -0.76530612244897966 0.19999999999999996, -1.00612244897959191 0.17551020408163254, -1.1489795918367347 0.06122448979591832, -1.15714285714285703 0.09387755102040807, -1.04285714285714293 0.19183673469387752, -0.89183673469387759 0.2326530612244897, -1.01428571428571423 0.33877551020408159, -0.9285714285714286 0.35510204081632646, -0.83061224489795915 0.23673469387755097, -0.66326530612244894 0.2204081632653061, -0.6020408163265305 0.14285714285714279, -0.51632653061224487 0.20408163265306112, -0.41428571428571415 0.30204081632653057, -0.25102040816326521 0.26938775510204072, -0.17755102040816317 0.33061224489795915, -0.0428571428571427 0.39591836734693875, 0.03061224489795933 0.25714285714285712, -0.02653061224489806 0.25306122448979584, -0.03877551020408143 0.31836734693877544, -0.15714285714285703 0.28979591836734686, -0.18571428571428572 0.19999999999999996, -0.09591836734693882 0.06122448979591832, 0.00612244897959213 -0.05714285714285716, 0.16530612244897958 0.03265306122448974, 0.21020408163265314 0.1673469387755101, 0.16938775510204085 0.30204081632653057, 0.10000000000000009 0.39999999999999991, -0.11224489795918369 0.47755102040816322, -0.29999999999999982 0.42040816326530606, -0.29591836734693877 0.47346938775510194, -0.13673469387755088 0.52244897959183667, 0.12040816326530601 0.45714285714285707, 0.27551020408163263 0.25714285714285712, 0.24285714285714288 0.01632653061224476, 0.02653061224489806 -0.1183673469387756, -0.07551020408163245 -0.21632653061224505, 0.14897959183673493 -0.33061224489795937, 0.83061224489795915 -0.05306122448979611)')
    o = loads('Polygon ((-0.65918367346938767 -0.19183673469387763, -0.65510204081632639 -0.00408163265306127, -0.59795918367346923 0.07346938775510192, -0.56530612244897949 -0.02448979591836742, -0.5244897959183672 -0.00816326530612255, -0.55306122448979589 0.1020408163265305, -0.42244897959183669 0.18775510204081625, -0.26734693877551008 0.18775510204081625, -0.15306122448979576 0.05306122448979589, -0.25102040816326521 -0.01224489795918382, -0.27142857142857135 0.06938775510204076, -0.32448979591836724 0.06938775510204076, -0.29999999999999982 -0.04897959183673484, -0.25510204081632648 -0.11020408163265305, -0.15306122448979576 -0.09387755102040818, -0.16530612244897958 -0.24081632653061247, -0.34897959183673466 -0.25306122448979607, -0.41428571428571415 -0.17142857142857149, -0.50408163265306127 -0.13877551020408174, -0.58571428571428563 -0.22448979591836737, -0.65918367346938767 -0.19183673469387763))')

    l_coords = l.coords
    p_coords = o.exterior.coords[:-1]

    line_coords = []
    
    #l_id = 14
    #l_id = 22
    #o_id = 6
    
    l_id = 15
    o_id = 7
    
    dxx = 0.00001
    
    r = 0
    while r < len(l_coords):
        if r < l_id:
            line_coords += [(l_coords[r][0], l_coords[r][1])]
        elif r == l_id:
            line_coords += [(l_coords[r][0] - dxx, l_coords[r][1])]
            
            a = o_id
            while a >= 0:
                if a == o_id:
                    line_coords += [(p_coords[a][0] - dxx, p_coords[a][1])]
                else:
                    line_coords += [(p_coords[a][0], p_coords[a][1])]
                
                a -= 1
            
            a = len(p_coords) - 1
            #while a > o_id:
            while a >= o_id:
                if a == o_id:
                    line_coords += [(p_coords[a][0] + dxx, p_coords[a][1])]
                else:
                    line_coords += [(p_coords[a][0], p_coords[a][1])]
                
                a -= 1
            
            line_coords += [(l_coords[r][0] + dxx, l_coords[r][1])]
            
        else:
            line_coords += [(l_coords[r][0], l_coords[r][1])]
    
        r += 1

    line = LineString(line_coords)
    
    #print(line.wkt + ';')
    #sys.exit()

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    """
    chull_ids = []
    b = 0
    
    while b < n:
        chull_ids += [b]
        b += 1
    """
    
    k = len(chull_ids)
    
    """
    a = 0
    b = 0
    
    while a < k:
        if chull_ids[a] == n - 1:
            b = a
            break
        
        a += 1
    """
    
    #b = 0
    
    """
    if b > 1:
        b = int((b - 1) / 2)
        #b = int((b) / 2)
    """
    
    #print(chull_ids)
    #print(b)

    """
    if b > 0:
        p = 0
        ch = []
        
        while p < b:
            if chull_ids[p] + 1 != chull_ids[p + 1]:
                
                a = chull_ids[p]
                
                while a < chull_ids[p + 1]:
                    ch += [a]
                    a += 1
                
            p += 1

        a = b
        while a < k:
            ch += [chull_ids[a]]
            a += 1
        
        chull_ids = ch
        k = len(chull_ids)
    """
    
    #print(chull_ids)
    #sys.exit()
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()

    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
        
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    """
    b = 0
    
    if k > 1:
        b = int(k / 2)
    """
    
    # Principal line interpolation (optional).
    
    factor = 0.5
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        #if iseg.distance(line) > line_min_dist:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(f_x, f_y)
                
        msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
        msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
        seg_coords = iseg.coords
        s_t = e_t
        break
            
        #factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.4
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t, 1)
        
    i = 0
    w = 0
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            s = GeometryCollection([l, o])
            geoms += [s]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue

                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            # >>>>>
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            # >>>>>
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

# different final t.
def seg_to_line_4(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    """
    chull_ids = []
    b = 0
    
    while b < n:
        chull_ids += [b]
        b += 1
    """
    
    k = len(chull_ids)
    
    a = 0
    b = 0
    
    while a < k:
        if chull_ids[a] == n - 1:
            b = a
            break
        
        a += 1

    #b = 0
    
    if b > 1:
        b = int((b - 1) / 2)
        #b = int((b) / 2)
    
    #print(chull_ids)
    #print(b)

    """
    if b > 0:
        p = 0
        ch = []
        
        while p < b:
            if chull_ids[p] + 1 != chull_ids[p + 1]:
                
                a = chull_ids[p]
                
                while a < chull_ids[p + 1]:
                    ch += [a]
                    a += 1
                
            p += 1

        a = b
        while a < k:
            ch += [chull_ids[a]]
            a += 1
        
        chull_ids = ch
        k = len(chull_ids)
    """
    
    #print(chull_ids)
    #sys.exit()
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()

    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
        
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    """
    b = 0
    
    if k > 1:
        b = int(k / 2)
    """
    
    # Principal line interpolation (optional).
    
    factor = 1
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        #if iseg.distance(line) > line_min_dist:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(f_x, f_y)
                
        msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
        msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
        seg_coords = iseg.coords
        s_t = e_t
        break
            
        #factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.4
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t, 0.85)
        
    i = 0
    w = 0
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            geoms += [line]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue

                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            # >>>>>
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            # >>>>>
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

# convex hull + line
def seg_to_line_3(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    """
    chull_ids = []
    b = 0
    
    while b < n:
        chull_ids += [b]
        b += 1
    """
    
    k = len(chull_ids)
    
    a = 0
    b = 0
    while a < k:
        if chull_ids[a] == n - 1:
            b = a
            break
        
        a += 1
    
    
    #b = 0
    
    if b > 1:
        b = int((b - 1) / 2)
        #b = int((b) / 2)
    
    #print(chull_ids)
    #print(b)
    
    if b > 0:
        p = 0
        ch = []
        
        while p < b:
            if chull_ids[p] + 1 != chull_ids[p + 1]:

                """
                a = 0
                for a < p:
                    ch += [chull_ids[p]]
                """
                
                a = chull_ids[p]
                
                while a < chull_ids[p + 1]:
                    ch += [a]
                    a += 1
                
            p += 1
    
        #print(ch)
    
        a = b
        while a < k:
            ch += [chull_ids[a]]
            a += 1
        
        chull_ids = ch
        k = len(chull_ids)
    
    #print(chull_ids)
    #sys.exit()
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()

    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
        
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    """
    b = 0
    
    if k > 1:
        b = int(k / 2)
    """
    
    # Principal line interpolation (optional).
    
    factor = 1
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        #if iseg.distance(line) > line_min_dist:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(f_x, f_y)
                
        msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
        msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
        seg_coords = iseg.coords
        s_t = e_t
        break
            
        #factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.5
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t)
        
    i = 0
    w = 0
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            geoms += [line]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue

                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            # >>>>>
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            # >>>>>
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

# Follow the line instead of the convex-hull.
def seg_to_line_2(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    """
    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    """
    
    chull_ids = []
    b = 0
    
    while b < n:
        chull_ids += [b]
        b += 1
    
    k = len(chull_ids)
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()

    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
        
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    # Principal line interpolation (optional).
    
    factor = 1
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        #if iseg.distance(line) > line_min_dist:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(f_x, f_y)
                
        msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
        msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
        seg_coords = iseg.coords
        s_t = e_t
        break
            
        #factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.5
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t)
        
    i = 0
    w = 0
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            geoms += [line]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue

                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            # >>>>>
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            # >>>>>
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

def seg_to_line(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    k = len(chull_ids)
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()

    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
        
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    # Principal line interpolation (optional).
    
    factor = 1
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        #if iseg.distance(line) > line_min_dist:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(f_x, f_y)
                
        msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
        msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
        seg_coords = iseg.coords
        s_t = e_t
        break
            
        #factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.5
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t)
        
    i = 0
    w = 0
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            geoms += [line]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue

                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            # >>>>>
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            # >>>>>
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

def seg_to_concavity(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.

    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    k = len(chull_ids)
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()
    
    #print(_ik, _fk)
    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    #print(chull_ids, _ik, _fk)
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        #print(_id, f, _ik, _fk, new_chull_ids)
        
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    #print(f)
    
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
    
    #print(chull_ids)
    #sys.exit()
    
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    #print(chull_ids, i_vis_idx, f_vis_idx, _n_segs, i_last_idx, f_last_idx)
    
    """
    ied = 0
    fed = n - 1
    
    if chull_ids[0] != ied
    
    _iv = 0
    _fv = n - 1
    
    lmi = chull_ids[0]
    rmi = right_index2(line_coords)
    
    print(chull_ids)
    print(_iv, _fv, lmi, rmi)
    """
    
    ### >>>>>>>>>>>>>
    
    # I think that the following is unnecessary if working with lines whose endpoints see each other.
    # it should only be necessary to check that the endpoints see each other.
    # Complexity O(n2).
    
    """
    _ch = []
    _h = 0
    _r = []
    while _h < k - 1:
        _ch += [chull_ids[_h]]
        
        if chull_ids[_h] > chull_ids[_h+1]:
            if chull_ids[_h] != n - 1:
                _ch += [n - 1]
            
            _h += 1
            while _h < k:
                _r += [chull_ids[_h]]
                _h += 1
            
            break
        
        if _h == k - 2:
            _ch += [chull_ids[_h+1]]
        
        _h += 1
    
    _h = 0
    _j = len(_r)
    _temp = []
    
    if _j == 1:
        if _r[0] < chull_ids[0]:
            _temp += [_r[0]]
    elif _j > 1:
        while _h < _j - 1:
            if _r[_h] > _r[_h+1]:
                if _h == _j - 2:
                    if _r[_h+1] < chull_ids[0]:
                        _temp += [_r[_h+1]]
                
                _h += 1
                continue
            
            _temp += [_r[_h]]
            if _h == _j - 2:
                _temp += [_r[_h+1]]
            
            _h += 1
        
    _r = _temp
    chull_ids = _r + _ch
    
    #print(chull_ids)
    
    if chull_ids[0] != 0:
        if chull_ids[0] - 1 == 0:
            chull_ids[0] = 0
        else:
            chull_ids = [0] + chull_ids
    
    k = len(chull_ids)
    
    #print(chull_ids)
    
    i_vis_idx = -1
    f_vis_idx = -1
    _m = 0
    
    while _m < k:
        A = Point(seg_coords[0][0], seg_coords[0][1])
        B = Point(line_coords[chull_ids[_m]][0], line_coords[chull_ids[_m]][1])
        
        _ll = LineString([(A.x, A.y), (B.x, B.y)])
        
        if not _ll.crosses(line):
            i_vis_idx = chull_ids[_m]
            break
        
        _m += 1
    
    i_last_idx = _m
    f_last_idx = -1
    
    _m = k - 1
    
    while _m > i_last_idx:
        A = Point(seg_coords[1][0], seg_coords[1][1])
        B = Point(line_coords[chull_ids[_m]][0], line_coords[chull_ids[_m]][1])
        
        _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
        if not _ll.crosses(line):
            f_vis_idx = chull_ids[_m]
            f_last_idx = _m
            break
        
        _m -= 1
        
    _n_segs = f_last_idx - i_last_idx
    
    if f_last_idx == -1 or i_last_idx == -1:
        print_error('The endpoints of the target are not visible to the source!"')
        sys.exit()
    """
    
    """
    print(i_last_idx)
    print(f_last_idx)
    print(chull_ids)
    """
    #sys.exit()
    
    ### <<<<<<<<<<<<<
    
    # Principal line interpolation (optional).
    
    factor = 0.25
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        if iseg.distance(line) > line_min_dist:
            A = Point(seg_coords[0][0], seg_coords[0][1])
            B = Point(f_x, f_y)
                
            msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
            msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
            seg_coords = iseg.coords
            s_t = e_t
            break
            
        factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.5
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t)
        
    i = 0
    w = 0
    
    """
    print(_isegs)
    print(len(_isegs))
    sys.exit()
    """
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            # Todo: compute the time step for each transform path.
            
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            geoms += [seg]
        elif t == 1:
            geoms += [line]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue
                
                # All Points (No Filter).
                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            #
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]
            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                #elif _X1 == _X0 and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                #    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            #
            
            g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
                #print_error(g.wkt + '; ' + str(i))
                #print(g.wkt + ';', i)
                #sys.exit()
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms

# experiment with alg + simplified rot plane
def seg_to_concavity_extended(seg, line, num_samples):
    # The algorithm assumes that the segment and the line are in a standart position.
    seg_wkt = 'LINESTRING(-140.38800507462761402 -54.16228782222089677, -140.07039179647233595 -54.18960939453533143)'
    line_wkt = 'LINESTRING(-140.38800507462761402 -54.16228782222089677, -140.33848472480769942 -54.09569148970446406, -140.39312786943656874 -54.0393407468059479, -140.34360751961665414 -54.02738755891838451, -140.30774795595397109 -54.06495472085072862, -140.20016926496589349 -54.05812432777211995, -140.16089450476388834 -54.12130546374925189, -140.10795895840468006 -54.08715349835620856, -140.07039179647230753 -54.10252188278307273, -140.13698812898874735 -54.15033463433333338, -140.07039179647233595 -54.18960939453533143)'
    
    seg_wkt = 'LINESTRING(-140.50924455177292316 -54.26986651320897437, -140.06526900166338123 -54.25620572705175704)'
    
    seg = loads(seg_wkt)
    line = loads(line_wkt)

    a_wkt = 'LINESTRING(-140.06526900166338123 -54.25620572705175704, -139.86377240584442916 -54.10935227586167429)'
    b_wkt = 'LINESTRING(-139.86377240584442916 -54.10935227586167429, -139.78522288544041885 -53.90444048350342854)'
    c_wkt = 'LINESTRING(-139.78522288544041885 -53.90444048350342854, -140.05160821550614969 -53.74051104961682768)'
    d_wkt = 'LINESTRING(-140.05160821550614969 -53.74051104961682768, -140.4409406209868223 -53.76100222885264657)'
    e_wkt = 'LINESTRING(-140.4409406209868223 -53.76100222885264657, -140.61511564449133971 -53.89761009042481987)'
    f_wkt = 'LINESTRING(-140.61511564449133971 -53.89761009042481987, -140.70732595105255314 -54.11618266894028295)'
    g_wkt = 'LINESTRING(-140.70732595105255314 -54.11618266894028295, -140.50924455177292316 -54.26986651320897437)'

    sa = loads(a_wkt)
    sb = loads(b_wkt)
    sc = loads(c_wkt)
    sd = loads(d_wkt)
    se = loads(e_wkt)
    sf = loads(f_wkt)
    sg = loads(g_wkt)

    a_wkt = 'LINESTRING(-140.07039179647233595 -54.18960939453533143, -139.92695354182154688 -54.07690790873829201)'
    b_wkt = 'LINESTRING(-139.92695354182154688 -54.07690790873829201, -139.91670795220363743 -53.91468607312134509)'
    c_wkt = 'LINESTRING(-139.91670795220363743 -53.91468607312134509, -140.10795895840468006 -53.815645373481523)'
    d_wkt = 'LINESTRING(-140.10795895840468006 -53.815645373481523, -140.4289874330992518 -53.80539978386360644)'
    e_wkt = 'LINESTRING(-140.4289874330992518 -53.80539978386360644, -140.56730289294108616 -53.9317620558178632)'
    f_wkt = 'LINESTRING(-140.56730289294108616 -53.9317620558178632, -140.59633206352518187 -54.07520031046864517)'
    g_wkt = 'LINESTRING(-140.59633206352518187 -54.07520031046864517, -140.38800507462761402 -54.16228782222089677)'

    ta = loads(a_wkt)
    tb = loads(b_wkt)
    tc = loads(c_wkt)
    td = loads(d_wkt)
    te = loads(e_wkt)
    tf = loads(f_wkt)
    tg = loads(g_wkt)

    objs = [[sa, ta]]
    objs += [[sb, tb]]
    objs += [[sc, tc]]
    objs += [[sd, td]]
    objs += [[se, te]]
    objs += [[sf, tf]]
    objs += [[sg, tg]]
    
    seg_coords = seg.coords
    d_seg = seg.length
    
    line_coords = line.coords
    
    seg_dist_threshold = 0.8   
    line_min_dist = 0.2
    msegs = []
    isegs = []
        
    d_max = 0
    
    ix = sys.float_info.max
    fx = sys.float_info.min

    id_x = -1
    fd_x = -1
    
    n = len(line_coords)
    k = 0
    
    s_t = 0
    e_t = 0.15
        
    # Initial Segs > Convex-Hull.

    points = []
    for coord in line_coords:
        points.append(Point(coord[0], coord[1])) 
    
    # O(n2)
    chull_ids = convex_hull_2(points, len(points))
    
    k = len(chull_ids)
    
    global OPT
    
    _ik = 0
    _fk = n - 1
    
    if OPT == 1:
        _ik = chull_ids[0]
        _fk = right_index(points)
        
        print_error('TODO!"')
        sys.exit()
    
    #print(_ik, _fk)
    ### >>>     Test Visibility.
    
    # s_0
    A = Point(seg_coords[0][0], seg_coords[0][1])
    B = Point(line_coords[_ik][0], line_coords[_ik][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The initial endpoint of the target is not visible to the source!"')
        sys.exit()
    
    # s_1
    A = Point(seg_coords[1][0], seg_coords[1][1])
    B = Point(line_coords[_fk][0], line_coords[_fk][1])
        
    _ll = LineString([(A.x, A.y), (B.x, B.y)])
                
    if _ll.crosses(line):
        print_error('The final endpoint of the target is not visible to the source!"')
        sys.exit()
    
    #print(chull_ids, _ik, _fk)
    
    ### End Visibility Test.
    new_chull_ids = []
    f = 0
    
    for _id in chull_ids:
        #print(_id, f, _ik, _fk, new_chull_ids)
        
        if _id == _ik:
            new_chull_ids += [_id]
            f = 1
        elif f == 1 and _id == _fk:
            new_chull_ids += [_id]
            f = 2
            break
        elif f == 1:
            new_chull_ids += [_id]
        
    #print(f)
    
    if f != 2:
        chull_ids = [_ik, _fk]
        
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = 1
    else:
        chull_ids = new_chull_ids
    
        i_vis_idx = _ik
        f_vis_idx = _fk
        
        _n_segs = len(chull_ids) - 1
    
    #print(chull_ids)
    #sys.exit()
    
    k = len(chull_ids)
    
    i_last_idx = 0
    f_last_idx = len(chull_ids) - 1
    
    #print(chull_ids, i_vis_idx, f_vis_idx, _n_segs, i_last_idx, f_last_idx)
       
    ### >>>>>>>>>>>>>
    
    # I think that the following is unnecessary if working with lines whose endpoints see each other.
    # it should only be necessary to check that the endpoints see each other.
    # Complexity O(n2).
     
    #sys.exit()
    
    ### <<<<<<<<<<<<<
    
    # Principal line interpolation (optional).
    
    factor = 0.25
    
    while factor > 0:
        id_x = i_vis_idx
        fd_x = f_vis_idx
        
        i_seg_x = line_coords[id_x][0]
        i_seg_y = line_coords[id_x][1]
            
        f_seg_x = line_coords[fd_x][0]
        f_seg_y = line_coords[fd_x][1]
            
        i_x = seg_coords[0][0] + factor * (i_seg_x - seg_coords[0][0]);
        i_y = seg_coords[0][1] + factor * (i_seg_y - seg_coords[0][1]);

        f_x = seg_coords[1][0] + factor * (f_seg_x - seg_coords[1][0]);
        f_y = seg_coords[1][1] + factor * (f_seg_y - seg_coords[1][1]);

        iseg = LineString([(i_x, i_y), (f_x, f_y)]);
            
        if iseg.distance(line) > line_min_dist:
            A = Point(seg_coords[0][0], seg_coords[0][1])
            B = Point(f_x, f_y)
                
            msegs += [MSeg(A, A, Point(i_x, i_y), Point(f_x, f_y), s_t, e_t)]
            msegs += [MSeg(Point(seg_coords[0][0], seg_coords[0][1]), Point(seg_coords[1][0], seg_coords[1][1]), B, B, s_t, e_t)]
                
            seg_coords = iseg.coords
            s_t = e_t
            break
            
        factor -= 0.1

    # End principal line interpolation (optional).
    
    i = 0
    
    # Divide the current segment in the transformation in n segments. O(k)
    segs = []
    
    if _n_segs == 1:
        segs += [[(seg_coords[0][0],seg_coords[0][1]), (seg_coords[1][0], seg_coords[1][1])]]
    else:
        f = float(1) / _n_segs
        
        dx = (seg_coords[1][0] - seg_coords[0][0])
        dy = (seg_coords[1][1] - seg_coords[0][1])
        
        xstep = dx * f
        ystep = dy * f
        
        h = 0
        v = 1
        tup = (seg_coords[0][0], seg_coords[0][1])
        
        while h < k - 1:
        
            if h < i_last_idx or h >= f_last_idx:
                segs += [[]]
            else:
                x = seg_coords[0][0] + xstep * v
                y = seg_coords[0][1] + ystep * v
                    
                if h == k - 2 or h == f_last_idx - 1:
                    segs += [[(x, y), (seg_coords[1][0], seg_coords[1][1])]]
                else:
                    segs += [[tup, (x, y)]]
                    tup = (x, y)
                v += 1
            
            h += 1
    
    #print(segs)
    #sys.exit()
    
    # End Initial Segs > Convex-Hull.
    
    # Get transformations and the time interval associated with each set of transformations.
    
    e_t = 0.5
    _isegs = []
    
    while i < k - 1:
        j = i + 1
                
        if chull_ids[i] + 1 != chull_ids[j]:
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]
            _isegs += [get_isegs(_seg, line_coords, chull_ids, chull_ids[i], chull_ids[j], False)]
    
        i += 1
    
    _dt = get_time_step_from_isegs(_isegs, e_t)
        
    i = 0
    w = 0
    
    """
    print(_isegs)
    print(len(_isegs))
    sys.exit()
    """
    
    while i < k - 1:
        j = i + 1
                
        # Direct Seg > Seg Transformation.
        
        if chull_ids[i] + 1 == chull_ids[j]:
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                _i = chull_ids[i]
                _j = chull_ids[j]
                
                C = Point(line_coords[_i][0], line_coords[_i][1])
                D = Point(line_coords[_j][0], line_coords[_j][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t, True)]
                msegs += [MSeg(A, B, D, D, s_t, e_t, True)]
        
        # Seg > Line Transformation.
        else:
            A = None
            B = None
                
            C = None
            D = None
            
            # Intermediate Transformation.
            
            if i < i_last_idx:
                A = Point(seg_coords[0][0], seg_coords[0][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                #msegs += [MSeg(A, B, D, D, s_t, e_t)]
            elif i >= f_last_idx:
                A = Point(seg_coords[1][0], seg_coords[1][1])
                #B = Point(seg_coords[1][0], seg_coords[1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
            else:
                A = Point(segs[i][0][0], segs[i][0][1])
                B = Point(segs[i][1][0], segs[i][1][1])
                
                C = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                D = Point(line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])
                
                msegs += [MSeg(A, A, C, D, s_t, e_t)]
                msegs += [MSeg(A, B, D, D, s_t, e_t)]
                        
            # Fix Initial Point if Applicable.
            #if chull_ids[i] == 0:
            if chull_ids[i] + 1 != chull_ids[j]:
                A = Point(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1])
                msegs += [MSeg(A, A, A, A, e_t, 1)]
            
            # Seg > Line Thansform.
            
            _seg = [(line_coords[chull_ids[i]][0], line_coords[chull_ids[i]][1]), (line_coords[chull_ids[j]][0], line_coords[chull_ids[j]][1])]

            isegs = _isegs[w]
            
            _k = len(isegs)
            dt = float(1 - e_t) / (_k)
            
            _msegs, g_idx = get_msegs_from_isegs(line_coords, isegs, e_t, _k, _dt[w][0], 0)
            
            w += 1
        
            # Todo: compute the time step for each transform path.
            
            msegs += _msegs
                                   
            if chull_ids[i] + 1 != chull_ids[j] and i == k - 2:
                A = Point(line_coords[chull_ids[i+1]][0], line_coords[chull_ids[i]+1][1])
                msegs += [MSeg(D, D, D, D, e_t, 1)]
       
        i += 1
    
    #
    
    for obj in objs:
        a = obj[0]
        b = obj[1]
        
        A = Point(a.coords[0][0], a.coords[0][1])
        B = Point(a.coords[1][0], a.coords[1][1])
        
        C = Point(b.coords[0][0], b.coords[0][1])
        D = Point(b.coords[1][0], b.coords[1][1])
        
        msegs += [MSeg(A, A, C, D, 0, 1, True)]
        msegs += [MSeg(A, B, D, D, 0, 1, True)]
    
    """
    A = Point(sa.coords[0][0], sa.coords[0][1])
    B = Point(sa.coords[1][0], sa.coords[1][1])
    
    C = Point(ta.coords[0][0], ta.coords[0][1])
    D = Point(ta.coords[1][0], ta.coords[1][1])
    
    msegs += [MSeg(A, A, C, D, 0, 1, True)]
    msegs += [MSeg(A, B, D, D, 0, 1, True)]
    
    A = Point(sb.coords[0][0], sb.coords[0][1])
    B = Point(sb.coords[1][0], sb.coords[1][1])
    
    C = Point(tb.coords[0][0], tb.coords[0][1])
    D = Point(tb.coords[1][0], tb.coords[1][1])
    
    msegs += [MSeg(A, A, C, D, 0, 1, True)]
    msegs += [MSeg(A, B, D, D, 0, 1, True)]
    
    A = Point(sc.coords[0][0], sc.coords[0][1])
    B = Point(sc.coords[1][0], sc.coords[1][1])
    
    C = Point(tc.coords[0][0], tc.coords[0][1])
    D = Point(tc.coords[1][0], tc.coords[1][1])
    
    msegs += [MSeg(A, A, C, D, 0, 1, True)]
    msegs += [MSeg(A, B, D, D, 0, 1, True)]
    """

    # Generate Interpolation.
    
    i = 0
    t = 0
    n = num_samples - 1
    num_invalid_geoms = 0
    num_complex_geoms = 0
    geoms = []
    
    while i < num_samples:
        t = float(i) / n

        if t == 0:
            g = loads('Polygon ((-140.61511564449133971 -53.89761009042481987, -140.70732595105255314 -54.11618266894028295, -140.50924455177292316 -54.26986651320897437, -140.06526900166338123 -54.25620572705175704, -139.86377240584442916 -54.10935227586167429, -139.78522288544041885 -53.90444048350342854, -140.05160821550614969 -53.74051104961682768, -140.4409406209868223 -53.76100222885264657, -140.61511564449133971 -53.89761009042481987))')
            #geoms += [seg]
            geoms += [g]
        elif t == 1:
            g = loads('Polygon ((-140.56730289294108616 -53.9317620558178632, -140.59633206352518187 -54.07520031046864517, -140.38800507462761402 -54.16228782222089677, -140.33848472480769942 -54.09569148970446406, -140.39312786943656874 -54.0393407468059479, -140.34360751961665414 -54.02738755891838451, -140.30774795595397109 -54.06495472085072862, -140.20016926496589349 -54.05812432777211995, -140.16089450476388834 -54.12130546374925189, -140.10795895840468006 -54.08715349835620856, -140.07039179647230753 -54.10252188278307273, -140.13698812898874735 -54.15033463433333338, -140.07039179647233595 -54.18960939453533143, -139.92695354182154688 -54.07690790873829201, -139.91670795220363743 -53.91468607312134509, -140.10795895840468006 -53.815645373481523, -140.4289874330992518 -53.80539978386360644, -140.56730289294108616 -53.9317620558178632))')
            #geoms += [line]
            geoms += [g]
        else:
            coords = []
            M = 0
            
            for mseg in msegs:
                xi, yi, xf, yf = mseg.at(t)
                
                if xi == None:
                    continue
                
                # All Points (No Filter).
                _n = len(coords)

                if _n > 1:
                    _xi = coords[_n - 2][0]
                    _yi = coords[_n - 2][1]
                        
                    _xf = coords[_n - 1][0]
                    _yf = coords[_n - 1][1]
                        
                    if _xi == xi and _yi == yi and _xf == xf and _yf == yf:
                        continue

                coords += [[xi, yi]]
                coords += [[xf, yf]]               
            
            #coords += [[coords[0][0], coords[0][1]]]

            g = LineString(coords)
            g = g.simplify(0.000000001)
            
            #
            
            _DX = 0.000000001
            _C = g.coords
            _N = len(_C)
            _I = 1
            _Coords = [(_C[0][0], _C[0][1])]

            while _I < _N:
                _X0 = _C[_I-1][0]
                _Y0 = _C[_I-1][1]
                
                _X1 = _C[_I][0]
                _Y1 = _C[_I][1]
                
                if _X1 == _X0 and _Y1 == _Y0:
                    pass
                #elif _X1 == _X0 and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                #    pass
                elif _X0 - _DX <= _X1 and _X1 <= _X0 + _DX and _Y0 - _DX <= _Y1 and _Y1 <= _Y0 + _DX:
                    pass
                else:
                    _Coords += [(_C[_I][0], _C[_I][1])]
                
                _I += 1
            
            #
            
            _Coords += [(_Coords[0][0], _Coords[0][1])]
            g = Polygon(_Coords)
            
            #g = LineString(_Coords)
            
            geoms += [g]
            
            if not g.is_valid:
                num_invalid_geoms += 1
                        
            if not g.is_simple:
                num_complex_geoms += 1
                #print_error(g.wkt + '; ' + str(i))
                #print(g.wkt + ';', i)
                #sys.exit()
  
        i += 1

    return geoms, num_invalid_geoms, num_complex_geoms


### >>>>>

# Input.

p, q, op, n_obs, debug = get_input()

OPT = op

# Transformation.

geoms, num_invalid_geoms, num_complex_geoms = seg_to_concavity_extended(p, q, n_obs)

#geoms, num_invalid_geoms, num_complex_geoms = seg_to_concavity(p, q, n_obs)

#geoms, num_invalid_geoms, num_complex_geoms = seg_to_line(p, q, n_obs)
#geoms, num_invalid_geoms, num_complex_geoms = seg_to_line_2(p, q, n_obs)
#geoms, num_invalid_geoms, num_complex_geoms = seg_to_line_3(p, q, n_obs)
#geoms, num_invalid_geoms, num_complex_geoms = seg_to_line_4(p, q, n_obs)
#geoms, num_invalid_geoms, num_complex_geoms = seg_to_line_5(p, q, n_obs)

# Output.

print(n_obs)
print(num_invalid_geoms)
print(num_complex_geoms)

for g in geoms:
    print(g.wkt)